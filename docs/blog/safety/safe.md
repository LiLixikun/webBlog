# 前端安全

网络安全是一个很大的话题，这里简单介绍下作为前端工程师应该知道的的东西。包括跨站脚本(XSS)，跨站请求伪造(CSRF)，界面劫持操作，WebShell这几大类。

## CSRF 

**CSRF**(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义来完成非法操作。简单来说攻击步骤也很简单。

用户现在已经登录了A网站，在一定时间内不需要再次登录(cookie)。访问了恶意攻击者提供的引诱危险站点B, B站点调用A站点的某个接口，比如说提交接口。如果A站点没有做任何的CSRF防御，就会被攻击。

原理也很简单，因为B站点调用了A站点的提交接口，根据cookie匹配原则，调用哪个站点的接口就会携带哪个站点的cookie，携带的就是用户存在A站点的cookie，这个时候提交接口传递的参数实际上是B站点提供的。在用户无意识的情况下以用户的身份调用了接口。

有人会说，B站点调用A站点的接口会跨域啊，再说了我搞POST提交总行了吧。 首先，跨域只是一种说法，而一般的跨域只是前端拿不到接口的返回值，并不代表请求发不出去。再说了你POST请求，人家可以加一层代理转发，给你整的明明白白的。

常见的 **CSRF** 有以下几种：

1. 禁止第三方 **cookie**，但是有兼容问题。
2. 判断 **referrer**，很多的防盗链都是验证referrer的方式。

referrer就是发送请求的那个前端页面地址，可以通过referrer的方法进行屏蔽和过滤，但是他也有一个问题https是不发送referrer的，所以也算是兼容性的问题

还有就是有各种流氓长短域名可以绕过你的判断。

3. 验证token，每次动态刷新。
token 一般存在 Local Storage 里面，别的站点无法盗走

4. 强验证码+动态Toekn

目前最有效的方式还是验证码的方式或者人机交互的方式，以前可以通过CSRF调取用户资金，因为转账比较简单，但现在基本转账都会发送验证码之类的验证。

## XSS

为了不和层叠样式表 CSS 混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往 Web 页面里面插入恶意的 Script 代码，当用户浏览该页之时，嵌入其中Web里面的 Script 代码就会被执行，从而达到恶意攻击用户的目的


### XSS 攻击类型

![xss-type](/safe/xss-type.png)

假设我们页面中存在一个input或者textarea用来收集用户输入的数据，正常情况下不会有什么问题，假设用户输入的内容为 \<script>alert(1)</script>\。当我们将用户输入的这段内容通过innnerHTML添加到页面中时，就会运行该段代码，弹出alert。(在写这段文字的同时我的窗口已经弹了😭)

很多黑客都是先通过alert的方式先去试验网站是否可以被XSS，这也就意味着可以运行js里面的任何脚本

另一种是通过url参数攻击叫做反射型，假设我们网站url中携带的内容会渲染到页面。

```js
http://localhost:8080/index.html?name=yd
```

黑客可以发送如下的链接给用户，用户一旦打开就会执行脚本。

```js
http://localhost:8080/index.html?name=<script>alert(123)</script>
```

###  XSS 的危害
- 获取页面数据
- 获取cookie
- 修改前端逻辑
- 发送请求
- 获取用户的信息和登录态
- 欺骗用户


### 防止XSS攻击

- 可以在header中设置响应头 X-XSS-Protection，默认情况下禁止XSS攻击的

- CSP

内容安全策略(CSP Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括XSS和数据注入等攻击。

一般被攻击是我们的网站执行了其他网站的js脚本，注入了黑客的js代码。假设我们的网站设置了只允许加载自己网站的代码，那么注入的js脚本就没办法执行了。

```js
// 设置只允许执行自己网站的js脚本，
ctx.set('Content-Security-Policy', "default-src 'self'")

// 浏览器打开连接时4000端口的外部资源不能被加载
https://127.0.0.1:3000?from=<script src="http://127.0.0.1:4000/hack.js"></script>
```

- 转译字符
用户输入永远不可信任的，最普遍的做法就是转译输出的内容，对于引号，尖括号，斜杠进行转译，比如通过如下的函数，对用户输入的内容进行转译。

```js
// 引入xss
const xss = require('xss');

let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss")</script>');

// <h1 id="title">XSS Demo</h1>&lt;script&gt;alert("xss")&lt;/script&gt;

console.log(html);
```

xss保留了h1标签，因为他是安全的，对script标签进行了转译，因为他是不全安的，同样输出也是一样，需要转译。

- HttpOnly Cookie

可以通过禁止js访问cookie的方式防范这种攻击。

```js
response.addHeader('Set-Cookie', 'uid=112; path/; HttpOnly')
```

## Shell

它是以 asp、php、jsp 或者 cgi 等网页文件形式存在的一种命令执行环境，由于 webshell 其大多树是以动态脚本的形式出现，也有人呢称之为网站的后门工具。


还记得一次我在做文件上传前后端的时候，交付的给第三方测试机构，验证出居然可以通过我服务器文件存放的目录进入到服务器，这让我惊出一身冷汗。


如何防范呢？
**控制目录**，修改上传文件名、转译上传目录、判断文件名是否合法携带不安全的。
**控制权限**、让目录只有可读权限

## 点击劫持

点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击。
当你点击这个按钮的时候实际上是点击到了iframe中的某个按钮上，触发iframe嵌入网站的功能，比如想要给一个页面点赞，就可以把这个页面通过iframe伪装。

当你点击这个按钮的时候实际上是点击到了iframe中的某个按钮上，触发iframe嵌入网站的功能，比如想要给一个页面点赞，就可以把这个页面通过iframe伪装。
要防御这个其实很简单，只需要设置X-FRAME-OPTIONS响应头，X-FRAME-OPTIONS是一个http响应头，在现在浏览器有一个很好的支持，这个http响应头就是为了防御用iframe嵌套的点击劫持攻击。

```js
ctx.set('X-FRAME-OPTIONS', 'DENY')
```

## 参考

[当浏览器全面禁用三方 Cookie](https://segmentfault.com/a/1190000022386152)