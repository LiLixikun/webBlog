# 性能优化白皮书

## 为什么要性能优化

- 57%的用户更在乎网页 3秒 内是否加载完成
- 52%的在线用户认为网⻚打开速度影响 到他们对网站的忠实度
- 每慢1秒造成⻚面 PV 降低11%，用户满意度也随之降低降低16%。
- 近半数移动用户因为在10秒内仍未打开⻚面从而放弃。

::: tip 什么是PV
PV 即页面浏览量或点击量，是衡量一个网站或网页用户访问量。具体的说，PV 值就是所有访问者在 24 小时（0 点到 24 点）内看了某个网站多少个页面或某个网页多少次。PV 是指页面刷新的次数，每一次页面刷新，就算做一次 PV 流量。度量方法就是从浏览器发出一个对网络服务器的请求（Request），网络服务器接到这个请求后，会将该请求对应的一个网页（Page）发送给浏览器，从而产生了一个 PV
:::

## 性能优化学徒工

### 雅虎军规

![huyajungui.png](../../.vuepress/public/optimization/huya.png)

- 浏览器正常并发请求**5个**左右,大小100kb左右,压缩后 **30kb**
- 使用CND,CDN不会携带多余的 cookie,使用多个CDN，解决浏览器对同一个域名的并发
- Http2 多路复用  Keep-Alives

### 缓存策略

**缓存的优先级**

![cache.png](../../.vuepress/public/optimization/cache.png)

![cache-level.png](../../.vuepress/public/optimization/cache-level.png)

- cache-control
- expries
- etag
- last-modified

**本地强缓存**

本地缓存 **localStorage**(同步),存储最好不超过一半(2.5M)

**Web SQL** 可以存储 50M 在(localStorage不够使用,异步)

- 常用的库  jquery http 设置强缓存 版本不是经常改变
- 业务代码 本地缓存 md5 
- 启动查看本地是否有缓存的 JS 文件
- 有 判断是否过期
    已过期：删除两个key的值，拉取js文件 请求etag，请求js，增加两个key code
    没过期： 直接取缓存的代码 （eval、addScript）
- 没有 直接拉取js，请求js，增加两个key code    


如查看百度 localStorage

存储两对 key 
key1 - > 对应文件 md5
key2(md5) -> 对应code

> 首页一般不缓存(会导致别的都不更新)

### 网站协议

浏览器请求//xx.cn/a.js-->解析域名—>HTTP连接—>服务器处理文件—>返回数据-->浏览器解析、渲染文件

![http2.png](../../.vuepress/public/optimization/http2.png)


Keep-Alive解决的核心问 题就在此，一定时间内，同一域名多次请求数据，只建立一次HTTP请求，其他请求可复用每一次建立的连接通道，以达到提高请求 效率的问题。一定时间是可以配置的，HTTP1.1还是存在效率问题，第一个:串行的文件传输。第二个:连接数过多。HTTP/2对同一 域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了 这个新特性，最大的并发就可以提升到300，比原来提升了**60**倍


## 如何测试用户网速

1. HTML5 自带

**navigator.connection** (不是很准确)

2. img 实现

在服务器放个 1KB 的图片 看返回时间差 

3. 多普勒测速

分五次请求，计算公式
1. api?http1.0&t=1&size=0k
2. api?http1.1&t=2&size=0k
3. api?http1.1&t=3&size=0k
4. api?http1.1&t=4&size=10k
5. api?http1.1&t=5&size=40k


- T1 = DNS+New Connection+RTT
- T2 = New Connection+RTT
- T3 = RTT
- 10k/(t4-t3)~TCP bandwidth
- (40k-10k)/(t5-t4)~TCP bandwidth

如果网速慢 可以给用户出 一倍图,获取隐藏部分,只显示重要部分

window._WISE_INFO

::: tip
哪大削哪
请求合并
压缩合并
缓存优先
:::


## 渲染中优化

- **重绘影响**
- **如何规避**
- **重排影响**
- **高效渲染**

### CSS 是否会引起重排和重绘

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box {
            width:100px;
            height: 100px;
            border: 1px solid #ccc;
            border-radius: 50%;
            position: absolute;
            animation: cicleBox 2s infinite;
        }

        @keyframes cicleBox {
            0% {
                /* top: 0;
                left: 0; */
                transform:translate(0,0);
            }
            25% {
                /* top: 0;
                left: 200px; */
                transform:translate(200px,0);
            }
            50% {
                /* top: 200px;
                left: 200px; */
                transform:translate(200px,200px);
            }
            75% {
                /* top: 200px;
                left: 0; */
                transform:translate(0,200px);
            }
        }
    </style>
</head>
<body>
    <div class="box"></div>
</body>
</html>
```

使用 **top** **left** 会发现不断的 重绘和重拍

使用 **transform** 则没有

- Paint flashing 绿色代表重绘
- Layout 重排   


**分析：**

 	1. 网页的渲染流程
      	1. 浏览器的dom是分层的，网页是3D的。
      	2. 对DOM元素节点计算样式结果Recalculate Style样式重计算
      	3. 为每个节点生成图形位置Layout回流重排
      	4. 将每个节点绘制填充到图层中Paint
      	5. 图层作为纹理上传到GPU
      	6. Composite Layers 合成层把符合图层生成到页面
      	7. Composite Layers 做了什么？
           	1. 图层的绘制列表，准备好，主线程 commit 合成线程
           	2. 合成线程 viewport rt 划分图块
           	3. 生成位图   栅格化（光栅化） raster
           	4. 所有图块 GPU合成生成DarwQuad提交给浏览器渲染进程
           	5. viz组件  接收到DarwQuad 绘制到我们的屏幕上
 	2. 分层
      	1. 根元素，position分层，transform，半透明，css滤镜，canvas，video，overflow
      	2. GPU硬件加速：CSS3D，video，webgl，transform，will-change:transform
 	3. 重绘和重排（盒子动了必定重排）
      	1. offset，scroll，client，width 读取   会打断浏览器工作。造成重排。
      	2. 优化： requestAnimationFrame 下一帧去写（react利用了他：设置dom元素，读写分离）
      	3. cpu负责操作系统和程序和数据处理
      	4. gpu负责显示 数据处理 效率更高
      	5. fastdom控制读写分离的插件
      	6. csstriggers.com可查看是否引起重排重绘


![zongjie.png](../../.vuepress/public/optimization/zongjie.png)

### CSS 和 JS 是否会阻塞页面解析渲染

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>京程一灯</h1>
    <script>
      // DOM解析不影响 渲染依旧等待
      prompt('等待');
    </script>
  </body>
</html>
```

- JS 不会影响 DOM 解析,但是会影响页面渲染


## 页面加载性能优化

**基础**

![gainian1.png](../../.vuepress/public/optimization/gainian1.png)
![gainian1-1.png](../../.vuepress/public/optimization/gainian1-1.png)

**新增**

![gainian2.png](../../.vuepress/public/optimization/gainian2.png)
![gainian2-1.png](../../.vuepress/public/optimization/gainian2-1.png)

**概念**

![gainian3.png](../../.vuepress/public/optimization/gainian3.png)
![gainian3-1.png](../../.vuepress/public/optimization/gainian3-1.png)

**总结**
![render.png](../../.vuepress/public/optimization/render.png)


## 白屏
![baiping.png](../../.vuepress/public/optimization/baiping.png)

**FP**

![FP.png](../../.vuepress/public/optimization/FP.png)

**FCP/FMP**
![FCPFMP.png](../../.vuepress/public/optimization/FCPFMP.png)

**Lonag tasks**
![tasks.png](../../.vuepress/public/optimization/tasks.png)

### 获取浏览器的指标时间

```html
<script>
  let t = performance.timing;
  console.log(
    'DNS查询耗时 ：' + (t.domainLookupEnd - t.domainLookupStart).toFixed(0)
  );
  console.log('TCP链接耗时 ：' + (t.connectEnd - t.connectStart).toFixed(0));
  console.log(
    'request请求耗时 ：' + (t.responseEnd - t.responseStart).toFixed(0)
  );
  console.log(
    '解析dom树耗时 ：' + (t.domComplete - t.domInteractive).toFixed(0)
  );
  console.log('白屏时间 ：' + (t.responseStart - t.navigationStart).toFixed(0));
  console.log(
    'domready时间 ：' +
      (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0)
  );
  console.log(
    'onload时间 ：' + (t.loadEventEnd - t.navigationStart).toFixed(0)
  );

  if ((t = performance.memory)) {
    console.log(
      'js内存使用占比 ：' +
        ((t.usedJSHeapSize / t.totalJSHeapSize) * 100).toFixed(2) +
        '%'
    );
  }
</script>
```


官方的库 **vitals**

[vitals](https://www.npmjs.com/package/web-vitals)新增模块的数据都能拿到


## 总结

![way.png](../../.vuepress/public/optimization/way.png)

![last.png](../../.vuepress/public/optimization/last.png)
