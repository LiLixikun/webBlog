# 渲染流程



**分析：**

 	1. 网页的渲染流程
      	1. 浏览器的dom是分层的，网页是3D的。
      	2. 对DOM元素节点计算样式结果 Recalculate Style样式重计算
      	3. 为每个节点生成图形位置Layout回流重排
      	4. 将每个节点绘制填充到图层中Paint
      	5. 图层作为纹理上传到GPU
      	6. Composite Layers 合成层把符合图层生成到页面
      	7. Composite Layers 做了什么？
           	1. 图层的绘制列表，准备好，主线程 commit 合成线程
           	2. 合成线程 viewport rt 划分图块
           	3. 生成位图   栅格化（光栅化） raster
           	4. 所有图块 GPU合成生成DarwQuad提交给浏览器渲染进程
           	5. viz组件  接收到DarwQuad 绘制到我们的屏幕上
 	2. 分层
      	1. 根元素，position分层，transform，半透明，css滤镜，canvas，video，overflow
      	2. GPU硬件加速：CSS3D，video，webgl，transform，will-change:transform
 	3. 重绘和重排（盒子动了必定重排）
      	2. 优化： requestAnimationFrame 下一帧去写（react利用了他：设置dom元素，读写分离）
      	3. cpu负责操作系统和程序和数据处理
      	4. gpu负责显示 数据处理 效率更高
      	5. fastdom 控制读写分离的插件
      	6. csstriggers.com可查看是否引起重排重绘


## 页面分层
复合 compositor thread 就是把页面拆分成多个图层 **layers** 进行绘制,再进行复合
那些属性会分层?

- 根元素

- position


::: tip 知道吗?
如何查看图层?
:::

在 **performance** 里面点击 **Layers** 可以看到图层的范围


### 那些样式仅影响复合,不影响重绘

- Position  transform: translate(npx,npx);

- Scale transform:scale(n)

- Rotation transform: rotate(ndeg)

- Opacity opacity: 0-1;


## 影响重绘和重排的操作

**重绘** 是我们改动元素的字体颜色,背景色等外观元素时候,并不会改变它的大小,也不会影响其他元素的布局,这个时候就不需要重新构建渲染树。浏览器会对元素的样式重新绘制,这个过程叫做 "重绘"

重绘的触发: 任何对元素样式,如 **color**,**background-color** 等属性的改变,JS和CSS都会引起重绘。

**重排** 一般来说盒子动了必定必定会 **重排**

- 添加/删除元素
- 内容发生改变(文字数量或图片大小等等)
- display:none
- 移动元素位置
- 修改浏览器大小,字体大小

还有一些读取操作也可能引起重排
- offset(Top|Left|Width|Height)
- scroll(Top|Left|Width|Height)
- client(Top|Left|Width|Height)
- getComputedStyle()


这里有个疑问🤔️,为什么读取也会造成重排?

因为在用JS操作DO吗时,浏览器会把操作维护在一个队列中,当达到一定的数量浏览器再统一去执行队列中的操作.当去查询这些属性时,浏览器就会强制刷新队列。 因为如果不立即执行队列中的任务,有可能得到的结果是错误的。相当于你强制打断了浏览器的优化流程，引起了重排.


![zongjie.png](/optimization/zongjie.png)

## 优化 
1. 要能在使用 CSS3D 硬件加速的地方尽量使用,让GPU 参与进来,可以跳过布局和绘制阶段
2. FastDom作为应用程序/库和DOM之间的一个调节层。 通过批处理DOM访问，避免不必要的文档回流，极大地加快了布局性能的。
3. 每个度量/变异作业被添加到相应的度量/变异队列。 队列在下一个框架的转弯时被清空，使用 window.requestAnimationFrame。