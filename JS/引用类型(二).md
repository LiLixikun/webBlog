# Date 类型

创建一个日期对象,使用 **new** 操作符和 **Date** 构造函数即可

```js

var now = new Date(); //Sat Dec 28 2019 16:52:15 GMT+0800 (中国标准时间)
```

如果想根据特定的日期和时间创建日期对象,必须传入表示日期的毫秒数。为了简化这一计算，ECMAScript 提供了两个方法 ：**Date.parse()** 和 **Date.UTC()**

```js
console.log(Date.parse("2019-12-28"));  //1577491200000
```
两个方法都接收一个表示日期的毫秒数，然后尝试根据这个字符串返回相应日期的毫秒数，如果传入的字符串不能表示日期，那么它会返回NaN。

```js

var time0 = 1560525082000;                 // Fri Jun 14 2019 23:11:22的毫秒数
var time1 = Date.UTC("Jun 14, 2004");          // 1560525082000
var time2 = Date.parse("Jun 14, 2004");    // 获取1087142400000
var time3 = "2019-06-14 23:11:22";
 var time4 = Date.parse("Junfdd"); //NaN

new Date(time0);    // Fri Jun 14 2019 23:11:22 GMT+0800 (中国标准时间)
new Date(time1);    // Fri Jun 14 2019 23:11:22 GMT+0800 (中国标准时间)
new Date(time2);    // Fri Jun 14 2019 23:11:22 GMT+0800 (中国标准时间)
new Date(time3);    // Fri Jun 14 2019 23:11:22 GMT+0800 (中国标准时间)，后台调用Date.parse(time3)转化为毫秒
```

## 日期格式化方法

```js


var time = new Date();

console.log(time.toDateString()); //Sat Dec 28 2019
// "Tue Jun 18 2019"
console.log(time.toTimeString()); //17:05:37 GMT+0800 (中国标准时间)

console.log(time.toLocaleDateString());  //2019/12/28

console.log(time.toLocaleTimeString()); //下午5:05:58

console.log(time.toUTCString()); //Sat, 28 Dec 2019 09:06:12 GMT

console.log(time.toGMTString()); //Sat, 28 Dec 2019 09:06:24 GMT
```

## 日期/时间组件方法



# RegExp 类型

# Function 类型

在JavaScript中函数的创建方式有三种：函数声明（静态的）、函数表达式（函数字面量）、函数构造法（动态的，匿名的）

函数声明:

```js
function sum(num1,num2){
    return num1 + num2;
}
```

函数表达式的形式如下：

```js
var fun = function(){
    doSomething();
}
```

函数构造法构造函数的形式如下：

```js
var fun = new Function("para1","para2",...,"function body");    
```
>函数实际上是对象,每个函数都是Function类型的实例,而且都和其他引用类型一样具有属性和方法,函数名实际上也是指向 **函数指针**的对象,不会与某个函数绑定.

## 没有重载

函数(或对象方法)完全靠函数名称唯一确定，JS不将参数列表作为区分函数的依据。更关键的是，在JS中，函数是作为一种特殊对象类型存在的，函数的名字只是一个普通的变量，本质与var a = 1中的变量a没什么区别。所以如果你先后定义了两个同名函数，实际上相当于先后将两个函数对象绑定到了同一个变量上，所以后者必然覆盖前者，不会共存，也自然不存在重载了。

## 函数声明和函数表达式区别

解析器在率先读取函数声音,并使其在执行任何代码之前可用;至于函数表达式,则必须等到解析器执行到它所在的代码行,才会真正被解释执行

```js

alert(sun(10,10));
function sum(num1,num2){
    return num1+num2;
}

```

如上过程在代码执行开始之前,解析器就通过一个名为 **函数声明提升** 的过程,读取并将函数声明标价到执行环境中.


## 作为值返回
 函数名本身就是变量,所以函数也可以作为值来返回。

## 函数内部属性

在函数内部,有两个特殊的对象: **argumens** 和 **this**

argumens 的主要用途是保存函数参数, this 引用的是函数执行的环境对象。 当在全局作用域调用函数时, **this** 引用的是 全局对象 **window**

>arguments有callee 属性,该属性是一个指针,指向拥有这个 arguments 对象的函数

```JS

function sum(num){
    if(num<=1){
        return 1;
    }else{
        return num * arguments.callee(num-1);
    }
}

alert(sum(5))
```

## 函数属性和方法

每个函数都包含两个属性: **length** 和 **prototype**

length 表示 希望接收的命名参数的个数, 没有命名参数,则为0

对于引用类型而言,**prototype** 是保存它们所有实例方法的真正所在. 在 ECMAScript5 中,prototype 属性是不可枚举的,因此使用 **for-in** 无法发现

### apply() 和 call() 

这两个方法的用途都是在特定的作用域中调用函数,实际上等于设置 函数体内 **this** 对象的值

**apply()**

 接收两个参数:一个是在其中运行函数的作用域,另一个是参数 数组,也可以是 **Array** 实例

```js

function sum20(num1, num2) {
    return num1 + num2;
}

function callSum1(num1, num2) {
    return sum20.apply(this, arguments);
}

function callSum2(num1, num2) {
    return sum20.apply(this, [num1, num2])
}

console.log(callSum1(10, 10));
console.log(callSum2(10, 10));

```

**call()**
  
call() 方法与 apply() 作用相同,区别在于接收参数不同,第一个参数 this 值没有变化,其余参数都是直接传递给函数

```js
function sum(num1, num2) {
    return num1 + num2;
}

function callSum(num1,num2){
    return sum.call(this,num1,num2);
}

```

>apply() 和 call() 真正强大的地方是能够扩充函数赖以运行的作用域,借用其他对象的方法。也就是说可以实现继承

**bind()**


bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数

由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。

```js

var name = "小张", age = 18;
var db = {
    name: "德玛",
    age: 99
};
var obj = {
    name: "小刘",
    objAge: this.age,
    myFun: function () {
        console.log(this.name + "年纪:" + this.age);
    }
}

obj.myFun();
obj.myFun.call();
obj.myFun.call(db);
obj.myFun.apply(db);
obj.myFun.bind(db)(); //返回一个新函数 必须执行才调用

```



# 基本包装类型

为了便于操作基本类型的值, ECMAScript 提供了三个特殊的引用类型 : **Boolean**、**Number** 和 **String** 

每当读取一个基本类型的时候,后台就会创建一个对应的基本类型的对象,从而让我们能够调用一些方法来操作这些数据, 如下:

```js

var s1 = "some text";
var s2 = s1.substring(2);
```

在访问 s1 时,访问模式处于一种读取模式,也就是要从内存中读取字符串的值。在读取模式中访问字符串时,后台会自动完成以下处理:

1. 创建 String 类型的一个实例:
2. 在实例上调用指定的方法:
3. 销毁这个实例

三个步骤执行如下:

```js

var s1 = "some text";
var s2 = s1.substring(2);
s1 = null;

```

>引用类型与基本包装类型的主要区别就是对象的生存期


使用 **new** 操作符创建的引用类型的实例,在执行流离开当前作用域之前一直保存在内存中。而自动创建的基本包装类型的对象,则只存在一行代码的执行瞬间,然后立即被销毁。**这也意味着我们不能在运行时为基本类型添加属性和方法** ：

```js

var s1 = "some text";
s1.color = "red";
alert(s1.color); //undefine

```

>对基本包装类型的实例调用 **typeof** 会返回 **object** , 所有基本包装类型的对象在转换为布尔值时值都是 **true**

```js

var num = "25" ;
var num1 = Number(num);

alert(typeof num); //string
alert(typeof num1); //number

var num2 = new Number(num);
alert(typeof num2); //object

```


## Boolean 类型

Boolean 类型是与布尔值对应的引用类型。要创建 Boolean 对象，可以像下面这样调用 Boolean构造函数并传入 true 或 false 值

```js

var booleanObject = new Boolean(true);
```

Boolean 类型的实例重写了valueOf()方法，返回基本类型值true 或false；重写了toString()方法，返回字符串"true"和"false"。可是，Boolean 对象在 ECMAScript 中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象，例如：

```js

var falseObject = new Boolean(false); 
var result = falseObject && true; 
alert(result); //true 

var falseValue = false; 
result = falseValue && true; 
alert(result); //false

```

下面结果没什么好说的，上面的为 **true**  是因为 布尔表达式中的所有对象都会被转换为 true，因此 falseObject 对象在布尔表达式中代表的是 true。结果，true && true 当然就等于 true 了

基本类型和引用类型的布尔值区别

- typeof 操作符对基本类型回"boolean"，而对引用类型返回"object"。
  
- 由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。

```js

var falseObject = new Boolean(false);
var falseValue = true;
alert(typeof falseObject); //object 
alert(typeof falseValue); //boolean 
alert(falseObject instanceof Boolean); //true 
alert(falseValue instanceof Boolean); //false
```


## Number 类型

Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其中传递相应的数值。


```js

var numberObject = new Number(10);
```


Number类型重写了valueOf、toLocaleString()和toString()方法。valueOf()方法返回对象表示的进本类型的数值。另外两个方法返回字符串形式的数值。

### 属性

- Number.MAX_VALUE         
  
- Number.MIN_VALUE  

- Number.NAN 

- Number.prtotype

### 原型中方法

**toFixed()**

参数:可选的,小数点后出现的位数.[0-20]之间的值,如果省略则视其为0

返回值: 按指定的小数位返回的数值的字符串


```js

var num=1234.678;
num.toFixed();  //Returns '1234'
num.toFixed(1); //Returns '1234.7'
num.tofiexd(3); //Reutrns '1234.678'

```

**toExponential()**

参数:可选的。一个整数，指定小数点后的位数。默认为指定数字所需要的位数

返回值:以指数表示法表示给定对象的字符串。

```js

var num=77.123
console.log(num.toExponential());   //7.7123e+1
console.log(num.toExponential(3));  //7.712

```

**toPrecision()**

参数:可选的。一个整数，指定有效为数。

返回值:表示数值定点或指数表示法对象的字符串

```js

var num = 5.123456;
console.log(num.toPrecision());     //'5.123456'
console.log(num.toPrecision(1));     //'5'
console.log(num.toPrecision(5));     //'5.1235'
console.log(0.01.toPrecision(2));     // '0.010'

```
## String 类型

String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建

```js

var stringObject = new String("hello world");
```

String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承valueOf()、toLocaleString()和 toString()方法，都返回对象所表示的基本字符串值

String 类型的每个实例都有一个 **length** 属性，表示字符串中包含多个字符

```js

var stringValue = "hello world"; 
alert(stringValue.length); //"11"
```

### 字符方法

**charAt()**

以单字符串的形式返回给定位置的那个字符,如果超出索引则返回空串

参数:一个介于0 小于字符串长度的整数,没有提供默认 **0**

返回值:以单字符串的形式返回给定位置的那个字符串

```js

var strValue = "hello word";

console.log(strValue.charAt());//h
console.log(strValue.charAt(3)); // l
console.log(strValue.charAt(10)); // 空
```

**charCodeAt()**

该方法返回给定索引处字符的UTF-16代码的单元值的数字,如果超出范围返回NaN

参数: 大于或等于0且小于字符串长度的整数; 如果它不是数字，则默认为0

返回值: 表示给定索引处字符的 **UTF-16** 代码单元值的数字,如果超出索引返回 **NaN**

```js
var strValue = "hello word";

console.log(strValue.charCodeAt()); //104
console.log(strValue.charCodeAt(3)); //108
console.log(strValue.charCodeAt(10)); //NaN
```

### 字符串操作方法

**concat()**

用于将一或多个字符串拼接起来，返回拼接得到的新字符串

```js
var stringValue = "hello "; 
var result = stringValue.concat("world"); 

alert(result); //"hello world" 
alert(stringValue); //"hello"
```

>虽然 concat()是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符（+）。而且，使用加号操作符在大多数情况下都比使用concat()方法要简便易行（特别是在拼接多个字符串的情况下）

**slice()**

提取一个字符串区域，返回一个新的字符串。

参数 :
- 第一个参数,开始索引位置，如果为负数会被当做(字符串长度+开始值)

-  第二个参数,可选。从该索引处结束提取字符串(但不包括该索引值)。如果为负数会被当做(字符串长度+开始值)

返回值  : 返回一个从原字符串中提取出来的新字符串

```js

var s = "hello world";
console.log(s.slice(0, 3)); //'hel'
console.log(s.slice(3, 0)); //''
console.log(s.slice(-1, 3));//''
console.log(s.slice(3, 3)); //''
console.log(s.slice(3, -3)); //'lo wo'
```
**subString()**

该方法返回一个字符串从指定位置开始到指定字符数的字符。

参数 : 
- 第一个参数,一个0到字符串长度之间的整数。

- 第二个参数,可选，一个0到字符串长度之间的整数

> 如果第一个参数大于二个参数,则执行效果就像两个参数调换一样。如果参数中任意一个为负数则当在0来处理

返回值 ：提取第一个参数到第二个参数(不包括)之间的字符、

```js

var s = "hello world";

console.log(s.substring(0, 7)); //'hello w'
console.log(s.substring(3, 0)); //'hel'
console.log(s.substring(-1, 4));//'hell'
console.log(s.substring(2, 8)); //'llo wo'
```

**substr()**

该方法返回一个字符串从指定位置开始到指定字符数的字符。

参数:
- 第一个参数,开始提取字符的位置。如果是负值则被看作(strLength+start),其中strLength为字符串的长度


- 第二个参数,可选,提取的字符数。如果为0或负数则返回空串。

返回值 ：返回提取的字符串

```js

var s = "hello world";
console.log(s.substr(0, 3)); //'hel'
console.log(s.substr(3, 0)); //''
console.log(s.substr(-1, 3));//'d'
console.log(s.substr(3, 3)); //'lo '
console.log(s.substr(3, -3)); //''
```

### 字符串位置方法


从字符串中查找子字符串的方法：indexOf()和 lastIndexOf()

这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而 lastIndexOf()方法是从字符串的末尾向前搜索子字符串

**indexOf()**

返回第一次出现的指定值的调用对象内的索引，如果未找到返回 **-1**

参数 :

- 表示要搜索值的字符串

- 表示从字符串的那个位置开始搜索,默认 **0**

返回值: 
- 返回 子字符串的第一次出现的索引值,没有找到返回 **-1** 

- 空字符串返回0到开始搜索索引的(该值大于0小于str.length)

```js

var str = 'hello world';
console.log(str.indexOf('hello'));     //0
console.log(str.indexOf('l'));        //2
console.log("".indexOf('l', 3));        //-1
console.log(str.indexOf(''));        //0
console.log(str.indexOf('', 4));        //4
console.log(str.indexOf('', 12));    //11 str.length
```


**lastIndexOf()**

返回指定值的最后一次出现的调用对象内的索引，如果未找到返回 **-1**

参数:
- 表示要搜索的值的字符串

- 第二个参数可选,表示字符串中从指定位置向前搜索

返回值:从后往前搜索字符串出现的索引值,未找到 **-1**

```js

var strValue = "helloxx oel";

console.log(strValue.lastIndexOf('o')); //8
console.log(strValue.lastIndexOf('o', 7)); //4
console.log(strValue.lastIndexOf('o', 2)); //-1
```

### trim()方法

这个方法创建一个字符串的副本,删除前置及后缀的所有空格,然后返回结果。不影响原字符串。

```js

var stringValue = " hello world "; 
var trimmedStringValue = stringValue.trim(); 

alert(stringValue); //" hello world " 
alert(trimmedStringValue); //"hello world"
```

### 字符串大小写转换方法

**toLocaleLowerCase()** 和 **toLocaleUpperCase()** 针对特定地区的实现

**toLowerCase()**

返回调用字符串值转换为小写。该方法不会影响原值

**toUpperCase()**

返回调用字符串值转换为大写。该方法不会影响原值

```JS

var stringValue = "hello world"; 

alert(stringValue.toUpperCase()); //"HELLO WORLD" 
alert(stringValue.toLowerCase()); //"hello world"
```

### 字符串的模式匹配方法

**math()** 方法

match()函数用于使用指定的正则表达式模式在当前字符串中进行匹配查找，并返回数组形式的查找结果。

参数 :包含正则表达式模式的RegExp对象的实例。也可以是包含正则表达式模式的变量名或字符串

> 如果参数regExp不是正则表达式对象(RegExp)，而是字符串类型，则match()先将该字符串传递给RegExp的构造函数，将其转换为一个RegExp对象

返回值 ：match()方法的返回值为Array类型，其返回数组的成员取决于指定的正则表达式模式是否设有全局标志g。

如果参数regExp没有全局标志g，则match()函数只查找第一个匹配，并返回包含查找结果的数组，该数组对象包含如下成员

- 索引0：存放第一个匹配的子字符串。
- 属性index：匹配文本在字符串中的起始索引位置。
- 属性input：整个字符串对象(stringObject)。

```js
var match = str.match('l');
console.log(match); //["l", index: 2, input: "hello world", groups:undefined] 
```

如果参数regExp设有全局标志g，则match()函数会查找所有的匹配，返回的数组不再有index和input属性

```js
var strValue = "helloxx oel";

console.log(strValue.match(/el/g)); //["el", "el"]

```

match()函数如果没有查找到任何匹配，则返回null

```js
var str = 'hello world';
console.log(str.match(/ain/g)); //null
```

**search()**

参数: **search()** 方法的参数和 **match()** 方法的参数相同

返回值: 返回字符串中第一个匹配项的索引，如果没有找到返回 **-1**

```js
var str = 'hello world';
console.log(str.search('o')); //4
console.log(str.search('y'));  //-1
```

**replace()**

该方法返回一个由替换值替换一些或所有匹配的模式后代的新字符串。模式可以是字符串或者一个正则表达式。

参数:

-  第一个参数，为模式或者一个要被替换的字符串
-  第二个参数,替换第一个参数的字符串。或者是一个而创建新字符串的函数

返回值: 一部分或全部匹配由代替模式所取代的新字符串

```js

var re = /cc/ig;
var str = "my name is cc,cc is my name";
str.replace(re, "wgs");
console.log(str); //"my name is wgs,wgs is my name"
console.log(str.replace("cc", "wgs"));//"my name is wgs,cc is my name"
```

**split()**

该方法基于指定的分隔符将一个字符串分隔成多个子 字符串,并将结果放在一个数组中.

参数:
- 分隔符:可以是字符串，也可以是 **RegExp** 对象

- 用于指定数组的大小

```js

var s = "tody is good day";
sonsole.log(s.split(" "));// ["tody", "is", "good", "day"]
sonsole.log(s.split(" ", 2));// ["tody", "is"]
```

**includes()**

includes() 方法用于判断字符串是否包含指定的子字符串。

如果找到匹配的字符串则返回 **true**，否则返回 **false**。

```js

var str = "Hello world, welcome to the Runoob。";
console.log(str.includes("world")) //true
```

### localeCompare()方法

这个方法比较两个字符串，并返回下列值中的一个：

- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定

- 如果字符串等于字符串参数，则返回 0

- 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的值同样要视实现而定）

```js

var stringValue = "yellow";
console.log(stringValue.localeCompare("brick")); //1 
console.log(stringValue.localeCompare("yellow")); //0 
console.log(stringValue.localeCompare("zoo")); //-1
```

### fromCharCode()方法

这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。

```js

alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello"
```

### repeat()

repeat() 方法字符串复制指定次数。

```js

var str1 = "Runoob";
console.log(str1.repeat(2));//RunoobRunoob
```