# Date 类型

# RegExp 类型

# Function 类型

在JavaScript中函数的创建方式有三种：函数声明（静态的）、函数表达式（函数字面量）、函数构造法（动态的，匿名的）

函数声明:

```js
function sum(num1,num2){
    return num1 + num2;
}
```

函数表达式的形式如下：

```js
var fun = function(){
    doSomething();
}
```

函数构造法构造函数的形式如下：

```js
var fun = new Function("para1","para2",...,"function body");    
```
>函数实际上是对象,每个函数都是Function类型的实例,而且都和其他引用类型一样具有属性和方法,函数名实际上也是指向 **函数指针**的对象,不会与某个函数绑定.

## 没有重载

函数(或对象方法)完全靠函数名称唯一确定，JS不将参数列表作为区分函数的依据。更关键的是，在JS中，函数是作为一种特殊对象类型存在的，函数的名字只是一个普通的变量，本质与var a = 1中的变量a没什么区别。所以如果你先后定义了两个同名函数，实际上相当于先后将两个函数对象绑定到了同一个变量上，所以后者必然覆盖前者，不会共存，也自然不存在重载了。

## 函数声明和函数表达式区别

解析器在率先读取函数声音,并使其在执行任何代码之前可用;至于函数表达式,则必须等到解析器执行到它所在的代码行,才会真正被解释执行

```js

alert(sun(10,10));
function sum(num1,num2){
    return num1+num2;
}

```

如上过程在代码执行开始之前,解析器就通过一个名为 **函数声明提升**的过程,读取并将函数声明标价到执行环境中.


## 作为值返回
 函数名本身就是变量,所以函数也可以作为值来返回。

## 函数内部属性

在函数内部,有两个特殊的对象: **argumens** 和 ***this*
argumens 的主要用途是保存函数参数, this 引用的是函数执行的环境对象。 当在全局作用域调用函数时, **this** 引用的是 全局对象 **window**

>arguments有callee 属性,该属性是一个指针,指向拥有这个 arguments 对象的函数

```JS

function sum(num){
    if(num<=1){
        return 1;
    }else{
        return num * arguments.callee(num-1);
    }
}

alert(sum(5))
```

## 函数属性和方法

每个函数都包含两个属性: **length** 和 **prototype**

length 表示 希望接收的命名参数的个数, 没有命名参数,则为0

对于引用类型而言,**prototype** 是保存它们所有实例方法的真正所在. 在 ECMAScript5 中,prototype 属性是不可枚举的,因此使用 **for-in** 无法发现

### apply() 和 call() 

这两个方法的用途都是在特定的作用域中调用函数,实际上等于设置 函数体内 **this** 对象的值

- apply()

 接收两个参数:一个是在其中运行函数的作用域,另一个是参数 数组,也可以是 **Array** 实例

```js

function sum20(num1, num2) {
    return num1 + num2;
}

function callSum1(num1, num2) {
    return sum20.apply(this, arguments);
}

function callSum2(num1, num2) {
    return sum20.apply(this, [num1, num2])
}

console.log(callSum1(10, 10));
console.log(callSum2(10, 10));

```

- call()
call() 方法与 apply() 作用相同,区别在于接收参数不同,第一个参数 this 值没有变化,其余参数都是直接传递给函数

```js
function sum(num1, num2) {
    return num1 + num2;
}

function callSum(num1,num2){
    return sum.call(this,num1,num2);
}

```

>apply() 和 call() 真正强大的地方是能够扩充函数赖以运行的作用域,借用其他对象的方法。也就是说可以实现继承

- bind()
bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数

由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。

```js

var name = "小张", age = 18;
var db = {
    name: "德玛",
    age: 99
};
var obj = {
    name: "小刘",
    objAge: this.age,
    myFun: function () {
        console.log(this.name + "年纪:" + this.age);

    }
}

obj.myFun();
obj.myFun.call();
obj.myFun.call(db);
obj.myFun.apply(db);
obj.myFun.bind(db)(); //返回一个新函数 必须执行才调用

```



