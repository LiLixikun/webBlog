# 基本类型和引用类型的值

ECMAScript变量包含两种不同数据类型的值:**基本数据类型** 和**引用数据类型**

在将一个值赋值给变量时,解析器必须知道这个值是基本数据类型还是引用数据类型.基本数据类型： Undefine、Null、Boolean、Number和String,这五种基本数据类型是按值访问的,因为可以操作保存变量中的实际的值.

引用数据类型的值是保存在内存中的对象. 在操作对象时,实际上是在操作对象的引用而不是实际的对象。为此,引用类型的值是按引用放完的.

##  属性的动态

创建一个变量并为该变量赋值. 对引用类型的值,我们可以为其添加属性和方法,也可以改变和删除其属性和方法 如下:

```js
var person = new Object();
person.name = "xxx";
alert(person.name) //"xxx"
```

>但是我们不能给基本数据类型的值添加属性,尽管这样做不会导致任何错误,如:

```js
var name = "aa";
name.age=18;
alert(name.age); //undefine 
```


##  复制变量值

如果从一个变量向另一个变量复制基本数据的值,会在变量对象上创建一个新值,然后把该值复制到为新变量分配的位置上。如：

```js
var num1 = 5;
var num2 = num1;
```

在使用num1的值来初始化num2时,num2中也保存了值5,但 num1 和 num2 中的5 时完全独立的, 该值只是 num1 的一个副本, 这两个变量可以参加任何操作而不会相互影响。

当一个变量向另一个变量复制引用类型的值时,同样也会在变量对象中复制一份放到为新变量分配的空间中。不同的是,这个值的副本实际上是一个指针,而这个指针指向存储在堆中的一个对象.复制操作结束后,两个变量实际上将引用同一个对象. 改变一个变量,就会影响另一个变量,如下:

```js
var obj1 = new Object();
var obj2 = obj1;
obj2.name = "xxx";
alert(obj1.name); //name
```

## 传递参数

ECMAScript中所有函数的参数都是按值传递的.也就是说,把函数外部的值复制给函数内部的参数,就和把值从一个变量复制到另一个变量一样.

再向参数传递基本数据的值时,被传递的值会被复制给一个局部变量. 再向参数传递引用类型的值时,会把这个值的在内存中的地址复制给一个局部变量,如下:

- 基本类型传参

```js
function add(num){
    num+=10;
    return num;
}

var count=20;
var result=add(10);
alert(count); //20 没有变化
alert(result) //30
```

- 引用数据类型传参

```js
function setName(obj){
    obj.name="name";
}

var person= new Object();
setName();
alert(person.name); //name
```

## 检测类型
 在检测基本数据类型的时 **typeOf** 是非常得力的帮手,但是在检测引用类型的值时,ECMAScript 为我们提供了 **instanceof** 操作符,语法如下:

 ```js
 result = variable instanceof constructor
 ```

 - 检测变量是Object
 ```js
 obj instanceof Object
 ```

- 检测变量是Object
 ```js
 obj instanceof Array
 ```

- 检测变量是RegExp
 ```js
 obj instanceof RegExp
 ```

在检测一个引用类型值和Object构造函数时,instanceof 操作符始终会返回 true,如果检测基本数据类型,始终会返回false, 因为基本类型不是对象.


# 执行环境与作用域

执行环境决定了变量或者函数有权访问的其他数据,决定了它们各自的行为. 每个执行环境都有一个与之关联的变量对象. 在Web浏览器中, 全局执行环境被认为是 **Window** 对象。

**查找变量的过程中,先找自己局部环境有没有变量或者函数,如果有,则查看声明有无赋值或者是函数的内容,如果没有,向上提升.**


1.执行环境决定了变量的生命周期，以及哪部分代码可以访问其中变量

2，执行环境有全局执行环境（全局环境）和局部执行环境之分。

3.每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链

4.函数的局部环境可以访问函数作用域中的变量和函数，也可以访问其父环境，乃至全局环境中的变量和环境。

5.全局环境只能访问全局环境中定义的变量和函数，不能直接访问局部环境中的任何数据。

6.变量的执行环境有助于确定应该合适释放内存。

## 延长作用域链
执行环境的类型总共有两种-- 全局 和 局部 ,但是还有其他方法来延长作用域链 ,如下:

- try-catch 语句的 catch 块

- with 语句

这两个语句都会在作用域链的前端添加一个变量对象。对 with 来说,会将执行的对象添加到作用域链中。 对 catch 来说,会创建一个新的变量对象,其中包含的是被抛出的错误对象的声明.

```js
function getUrl(){
    with(location){
       var url = href 
    }
    return url
}
```

在with 语句内部,定义了一个url 变量,因而url就成了执行函数执行环境的一部分,可以作为函数的值被返回.

## 没有块级作用域

在JavaScript 中,**if** 语句中的变量声明会将变量添加到当前的执行环境中.

```js
if(true){
    var age = 18;
}
alert(age); //18
```

在JavaScript中, **for** 语句初始化变量的表达式所定义的变量,即使在for 循环执行结束后,也依旧会存在于循环外部的执行环境中,如下:

```js
for (var i = 0; i<10; i++){
    doSomething(i);
}

alert(i); //10
```

### 声明变量

使用 **var** 声明的变量会自动被添加到最接近的环境中. 在函数内部,最接近的环境就是函数的局部环境; 在with 语句中,最接近的环境就是函数环境. 如果 **初始值变量没有使用var** 声明 ,该变量会自动被添加到 **全局环境中**.

- 全局变量
 在全局范围内声明的变量, 如 var a=1

- 局部变量
写入函数中的变量,叫做局部变量 

```js
function add(num){
    var result = num+10;
    return result;
}
alert(add()) //20
alert(result) // sum is not defined
```

如果省去 **var** 关键字, sum 将可以访问到 :

```js
function add(num){
    result = num+10;
    return result;
}
alert(add()) //20
alert(result) // 20
```

## 提升
 提升有变量提升和函数提升之分:

>变量提升

```js
1 var a = 123;
2 function fun() {
3    console.log(a);
4    var a = 456;
5 }
6 fun();
7 console.log(a);
```

上面输出结果是 **undefine** 和 **123**,分析一下fun() 的作用域链 : 自己的变量对象---->全局的变量对象。解析在在函数执行环境中发现了 变量 a,因此不会向全局环境的变量中寻找,解析器在解析第三行的时候还不知道 a 的值 是多少,也就是说只知道有 a 这个值,但是并不知道它具体位置(还没执行到第四行), 因此输出 **undefine**. 第七行输出是因为作用域问题,当 局部作用域有a 属性时,不会去修改全局环境的变量 a 

我们把代码调整下
```js
1 var a = 123;
2 function fun() {
3     var a ;
4    console.log(a);
5   a = 456;
6 }
7 fun();
8 console.log(a);
```

这个现象就是 **变量提升**

变量提升，就是把变量提升到函数的**顶部**，需要注意的是，变量提升只是提升变量的声明，**不会把变量的值也提升上来**


> 函数提升

函数提升就是把函数提升到前面。

在JavaScript中函数的创建方式有三种：函数声明（静态的,如上）、函数表达式（函数字面量）、函数构造法（动态的，匿名的）。函数表达式的形式如下：

```js
var fun = function(){
    doSomething();
}
```

函数构造法构造函数的形式如下：

```js
var fun = new Function("para1","para2",...,"function body");    
```


**只有函数声明形式才能被提升**

```js
//函数声明
function myTest1(){ 
    func(); 
    function func(){ 
        console.log("我可以被提升"); 
    } 
} 
myTest1();

//函数表达式
function myTest2(){ 
    func(); 
    var func = function(){ 
        console.log("我不能被提升"); 
    } 
} 
myTest2();
```

