# 箭头函数和传统JS的不同

- 没有 **this** 、 **super**、**arguments**、也没有 **new.target** 绑定
- 不能被使用 **new** 调用 : 箭头函数没有 [[Construct]] 方法, 因此不能被用作 构造函数, 使用 new 调用箭头函数会 抛出错误
- 没有原型: 既然不能对箭头函数使用 new, 那么它也不需要原型,也就没有 **prototype** 属性
- 不能更改 **this**,this 的值在函数内部不能被修改,默认在 创建时候和上下文绑定
- 没有 **arguments** 对象 必须依赖于具名参数或 剩余参数来访问函数的参数。
- 不允许重复的具名参数

没有 **arguments** 绑定

尽管箭头函数没有自己的 arguments 对象，但仍然能访问包含它的函数的 arguments 对
象。无论此后箭头函数在何处执行，该对象都是可用的。例如:

```js
function createArrowFunctionReturningFirstArg() {
    return () => arguments[0];
}
var arrowFunction = createArrowFunctionReturningFirstArg(5); console.log(arrowFunction()); // 5
```

仍然可以对箭头函数使用 call() 、 apply() 与 bind() 方法，虽 然函数的 this 绑定并不会受影响

```js
var sum = (num1, num2) => num1 + num2; console.log(sum.call(null, 1, 2));
console.log(sum.apply(null, [1, 2])); var boundSum = sum.bind(null, 1, 2); console.log(boundSum());
```

# 练习

```js

var age = 100;
var obj = {
    age: 20,
    say: () => {
        alert(this.age)
    }
}

obj.say();
```

**结果**:100
对象不能产生作用域，this指向的是window