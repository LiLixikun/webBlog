# 引用类型

引用类型的值(对象)是**引用类型**的一个实例。**引用类型**是一种数据结构,用于将数据和功能组织在一起. 引用类型有时候也被成为**对象定义**

## Object 类型
创建**Object**实例有两种方法,第一种是使用**new**操作符后跟**Object**构造函数;

```js
var person = new Object();  //也可以写成 person = {}
person.name='xxx';
person.age=28;
```

另一种使用方式使用**对象字面量**表示法

```js
var person = {
    name : 'xxx',
    age : 28
}
```

一般来说,访问对象属性时使用的都是**点**表示法,不过在 JS 也可以使用方括号表示法来访问对象的属性 .

```js
alert(person["name"]); //"xxx"
alert(person.age); // 28
```

方括号语法的只要有点是可以通过变量来访问属性。通常,除非必须使用变量来访问属性,否则我们使用**点表示法**,如下情况:

```js
person["first name"] = "xxx"
```

## Array 类型

创建数组的基本方式有两种,使用 Array 构造器

```js
var arr = new Array();
```

如果预先知道数组要保存的数量,可以给构造函数传递该数量,而该数量会自动变成 **length** 属性的值:

```js
var arr = new Array(10);
```

也可以向 **Array** 构造函数传递数组中包含的项

```js
var arr = new Array(20,'xx','name');
```

> 另外,在使用 Array 构造函数时可以省略 **new** 操作符

也可以使用数组字面量表示法:

```js
var arr = ['red','blue']; //创建一个包含2个字符串的数值
var arr1 = []; //创建一个空数组
var arr2 = [,,,,,] //不要这样 会创建一个包含5或者6项的数组
```

像这种省略值的情况下,每一项都将获得 **undefine** 值


数组的项数保存在其 **length** 属性中, length 并不是可读的,通过设置这个属性,可以从数组末尾移除项或向数组添加新项

```js
var colors = ['red','blue','green'];
colors.length=2;
alert(color[2]); //undefine
colors[colors.length]="black";
alert(colors[2]) //black
```

### 检测数组

对于一个网页或者一个全局作用域,使用 **instanceof** 操作符就能检测:

```js
if (value instanceof Array)
```

在ECMAScript5新值**Array.isArray()**方法,不管它在哪个全局执行环境中:

```js
if (Array.isArray(value))
```

### 转换方法

如前所述,所有对象都有 **toLocalString()**, **toString()**,**valueOf()**方法,调用toString()方法会返回由数组中的每个值的字符串形式拼接而成的一个以 **逗号** 分割的字符串, 而 valueOf() 返回的还是数组 .

```js
var colors = ['red','blue','green'];
alert(colors.toString()); //red,blue,green
alert(colors.valueOf()); //red,blue,green
```

数组继承的**toLocalString()**, **toString()**,**valueOf()**方法,在默认情况下会以**逗号**分割的字符串的形式返回数组项. 如果使用 **join()** 方法,接受一个参数,用作分隔符的字符串,然后返回包含所有数组项的字符串 .

```js
var colors = ['red','blue','green'];
alert(colors.join("||")) // rend||blue||green
```

## 栈方法

栈是一种 **LIFO** 的数据结构,也就是最新添加的项最早被移除. 而栈中项的**插入**(**推入**) 和 **移除**(弹出),只发生在一个位置 - 栈的顶部。 数组提供了 **push()** 和 **pop()** 方法

**push** 方法可以接收任意数量的参数,把它们添加到数组末尾,并返回修改后数组的长度. 而 **pop()** 方法则从数组尾部移除最后一项,减少数组的length,并返回移除的项。

```js
var colors = new Array();
var count = colors.push('red', 'green');
console.log(count); //2

var item = colors.pop();
console.log(item);; //green
console.log(colors.length); //1
```

### 队列方法

队列数据结构的访问规则是FIFO(先进先出). 队列在列表的**末端**添加项,从列表的**前端**移除项.

数组提供了 **shift()** 和 **unshift()** 方法.

- **shift()** 能够移除数组中的第一项并返回该项,同时将数组长度减 1 。

- **unshift()** 能在数组前端添加任意个项并返回数组的长度

```js
var colors = new Array();
var count = colors.unshift('red', 'green');
console.log(count); //2

var item = colors.shift();
console.log(item); //red
console.log(colors); //['green']
```

### 重排序方法

数组中的重排序方法: **reverse()** 和 **sort()** 

```js
var arr = [1, 2, 3, 4, 5];
arr.reverse();
console.log(arr); //[5, 4, 3, 2, 1]
```

在默认情况下,**sort()** 方法按升序排列数组项 - 即最小的值位于最前面,最大值排在最后面. 为了实现排序, sort() 方法会调用每个数组项的 **toString()** 转型方法,然后比较得到的字符串.  即使数组中的每一个项都是数值, sort() 方法比较的还是字符串 

```js
    var arr = [1, 2, 3, 4, 5];
    arr.reverse();
    console.log(arr);

    var values = [0, 1, 5, 10, 15];
    values.sort();
    console.log(values);  //[0, 1, 10, 15, 5]
```
看到这个结果我不淡定了,尼玛跟我想象的完全不一样啊。 结果查阅发现 字符串 对比为 **ASCII码比较**,依次取每个字符，字符转为 **ASCII码**进行比较，ASCII码先大的即为大；因为第一个字符**5**比**1**大所以后面就不用考虑了

这种排序方式肯定不是最佳方案, 因此 **sort()** 方法可以接收一个比较函数作为参数, 

> 比较函数接收两个参数
- 如果第一个参数应该位于第二个之前则返回一个负数

- 如果两个参数相等则返回0

- 如果第一个参数位于第二个参数之后则返回一个整数

升序

```js
var arr = [1, 2, 3, 4, 5];
arr.reverse();
console.log(arr);

function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value2 > value1) {
        return 1
    } else {
        0
    }
}

var values = [0, 1, 5, 10, 15];
values.sort(compare);
console.log(values); //[0, 1, 5, 10, 15]

```

降序

```js
var arr = [1, 2, 3, 4, 5];
arr.reverse();
console.log(arr);

function compare(value1, value2) {
    if (value1 < value2) {
        return 1;
    } else if (value2 > value1) {
        return -1
    } else {
        0
    }
}

var values = [0, 1, 5, 10, 15];
values.sort(compare);
console.log(values); //[0, 1, 5, 10, 15]

```

### 操作方法

**concat() 方法基于当前数组中的所有项创建一个新数组**

```js
var colors = ["red", "green", "blue"];
var colors1 = colors.concat("blcak", ["yellow", "brow"])
console.log(colors); //["red", "green", "blue"]
console.log(colors1); //["red", "green", "blue", "blcak", "yellow", "brow"]
```

**slice()，它能够基于当前数组中的一或对个项创建一个新数组**

slice() 方法可以接收一或两个参数,即要返回项的起始和结束位置.

- 只有一个参数的情况下, slice() 方法返回从该参数指定位置开始到数组末尾所有的项

- 有两个参数,该方法返回起始和结束位置之间的项 - 但不包括结束位置的项。

**slice() 方法不会影响原始数组**

一个参数

```js
var colors2 = colors1.slice(1);
console.log(colors2); // ["green", "blue", "blcak", "yellow", "brow"]
```

两个参数

```js
var colors3 = colors1.slice(1, 3);
console.log(colors3);//["green", "blue"]
```

>如果slice()方法参数中有一个负数,则用数组长度加上该数来确定相应的位置

```js
var colors4 = colors1.slice(-3, -1); //等于 colors1.slice(3, 5);
console.log(colors4); //["blcak", "yellow"]
```