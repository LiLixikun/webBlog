# 一 页面的加载和渲染过程

# 1 页面加载全过程
当我们在浏览器地址输入一个URL,d最终会呈现一个完整页面,大概会经历以下步骤：

[网页请求过程](https://segmentfault.com/img/bVbgNu4?w=1177&h=281)

## 1.1 HTML 加载
输入URL后首先拿到的是HTML,所以最先下载的是HTML,下载以后会对它进行解析.

## 1.2 其他静态资源下载
HTML在解析过程中,如果HTML引用其他的外部资源链接,如:JS和CSS和图片时,会启动别的线程来下载这些资源. 特殊的是,当遇到js文件时,HTML的解析会停下来,等JS文件下载完后再进行解析,因为JS有可能改变DOM的结果,重复操作,有白白浪费资源的风险，因此HTML解析器等JS下载完后再进行解析


## 1.3 DOM树构建
在HTML解析时候,解析器会把HTML解析成一个个DOM对象,而这些DOM最终会构建DOM 树。

```text
1.display的元素,注释存在于DOM树中

2.js会阻塞DOM树的构建从而阻塞其他资源的并发加载,因此最好把JS放在最后加载

3.对可能异步加载的JS使用 async 和defer
```

## 1.4 CSSOM 树构建
在CSS下载完后,CSS解析器会对CSS进行解析,会CSS解析成CSS对象，最终构建把这些CSS组装起来,构建CSSOM树。

```
1. js 会阻塞cssom的构建,只有js访问才会阻塞

2. cssom树的构建和dom树的构建是并行的

3. 减少css的嵌套(最好6层以内)和定义合理的css可以提高解析速度
```

## 1.5 渲染树构建
DOM树和CSS构建完成后,浏览器会根据这两棵树再构建一颗渲染树,它包含了可见的dom节点和节点的样式
```
1.渲染树的根节点是HTML节点

2.renderObject和dom不是完全对应的,不可见元素display:none是不会放入渲染树中的

3.visibility:hidden 的元素在Render Tree中
```

## 1.6 布局计算
渲染树构建完成后,所有的元素关系需要和应用样式关联,计算器会计算元素的大小和绝对位置.

```
1.float,flexd,absolute的元素会发生偏移
2.我们常说的脱离文档流,就是脱离布局。
```

## 1.7 绘制(Paint)
布局计算完成后,浏览器就可以在页面上渲染了,整个页面就呈现在屏幕上了.

## 1.8 重排(Reflow)与重绘(Replain)

渲染树是动态构建的,DOM节点和CSS节点的任何改变都会导致渲染树的重新构建,渲染树的改动就会导致重排与重绘

- **重排**

当我们在DOM树中新增,修改,删除,或者改变某些元素大小,位置,布局方式的时候,都要重新计算. 在改动发生时,要重新经历DOM的改动,CSSOM的构建,渲染树的构建,布局计算和绘制整个流程,这个过程就叫 **"重排"** ,有点也就 **"回流"**

回流的触发

1.dom元素的位置和大小发生改变

2.dom元素的增加和删除

3.伪类的激活

4.窗口大小的改变

5.增加和删除class样式

6.动态计算修改class样式

```
浏览器并不会每一次reflow都会执行,而是会积攒一部分,这个过程也被成为异步reflow,或者增量异步reflow. 但是有些情况浏览器是不这样做的,比如 resize 窗口,改变页面默认的字体等这些操作,浏览器会马上 reflow
```

- **重绘**

重绘是我们改动元素的字体颜色,背景色等外观元素时候,并不会改变它的大小,也不会影响其他元素的布局,这个时候就不需要重新构建渲染树。浏览器会对元素的样式重新绘制,这个过程叫做 **"重绘"**

重绘的触发：
任何对元素样式,如color,background-color等熟悉的改变,JS和CSS都会引起重绘。

